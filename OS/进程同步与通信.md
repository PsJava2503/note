# 进程同步与信号量

**临界区保护信号量    信号量实现进程同步**

### Peterson算法：

```java
进程P0
flag[0] = true;
trun = 1;
while (flag[1] && trun == 1);
临界区
flag[0] = false;

进程P1
flag[1] = true;
trun = 0;
while(flag[0] && turn == 0);
临界区
flag[1] = false;
剩余区
```

​		如果两个进程同时进入，那么flag[0]=flag[1]=true;对于进程P0,当flag[1]=true时，如果不空转，那么turn一定
为0，如果trun为0，进程P1就不可能进入。满足互斥

​		如果P1不在临界区，那么flag[1]=false,trun=0;而这两点无论满足哪一点P0都能进入。满足有空让进。
​		如果P0要求进入，那么flag[0]=true;那么P1不可能一直进入，因为当flag[0]=true时，如果P1想进入，turn必须要为1，但是如果P0不执行，P1每次执行都会将turn设置为0，因此当进程P0要求进入时，P1顶多还能先进入一次（当P0执行到trun=1时切出去执行P1）。满足有限等待。

以上都是考虑两个进程之间的调度，如果有n个进程呢？

## 多个进程调度

### 面包店算法：

面包店:每个进入商店的客户都获得一个号码，号码最小的先得到服务;号码相同时，名字靠前的先服务。

对应到进程切换来说就是给每个进程一个数字，调度的时候选择数字最小的先执行，执行完之后将该号码值为0，如果该进程还需要再次执行，那么就重新获取一个号码，并且这个号码比其他进程的号码都大。

```java
Pi进程
choosing[i]=true; 
num[i]=max(num[0],…，num[n-1 ])+1;	// 进程进来之前先取号，每次进入的时候都取最大那个
choosing[i]=false; 
for(j=0; j<n;j++)
{
	while(choosing[j]);	// 如果该进程在选号码，就停止
	while((num[j]!=0) && (num[j]，j)<(num[i]，i]));	
}
    临界区
num[i]=0;
    剩余区

```

​		首先 i 表示当前进程为Pi，num[j]!=0说明进程j想执行，(num[j],j) < (num[i],i),并且进程Pj的号码比进程Pi的号码小，那么就让进程Pi空转，让进程Pj执行，当进程Pj执行完之后,如果Pj进程不用执行了，那么num[j]==0,如果Pj进程还要执行，那么num[j]肯定大于num[i]，都会使Pi跳出空转。

​		面包店算法含有轮转+标记的意味，轮转体现在：每个进程第二次执行都至多要等n个进程，因为取号的时候是取的最大号，标记就是号码咯。很明显面包店算法也符合“互斥进入”、“有空让进”和“有限等待”。

​		面包店算法有自己的优点也有其缺点，优点前面已经说了，对于多进程的调度实现的比较好，而且是纯软件的不需要硬件支持；缺点就是太麻烦了，代码复杂。
下面说一种简单的方法

### 通过开关中断来实现

```
cin();
临界区
sti();
剩余区

```

cin()表示关中断，sti()开中断。进程怎么切换？还不是通过中断嘛，我直接把中断关了就不用切换了吧。CPU中断的原理：CPU旁边有个INTR寄存器，如果有中断来，就将INTR的某一位置为一，CPU每执行完一条指令之后就看一下是不是有中断来，如果有就执行；cin()函数的作用就是让CPU不看INTR寄存器，这样不管有没有中断来，CPU都不管。

但是这种方式对于多核不好使，因为你只能控制一个CPU，其他的CPU控制不了，而现在的计算机基本上都是多核了。这种方式只适用于单核的小系统。

### 硬件原子指令法

```c
boolean TestAndSet(boolean &x)
{
	boolean rv = x;
	x = true;
	return rv;
}

```

简单的讲，就是TestAndSet在执行的时候不会被打断。还记得最初的“直观想法”吗？就是简单的加锁开锁罢了，上面的这些什么算法都是实现这个加锁开锁的过程。同样硬件原子指令法也是这样，

```c
while(TestAndSet(&lock));
临界区
lock=false;
剩余区

```

很明显对于调度几个方面的要求都是符合的。它为什么叫硬件原子指令法呢？因为TestAndSet这条指令在执行的时候是对硬件有要求的，硬件必须这么设计才能支持这条指令。

# 死锁处理

#### 死锁的四个必要条件：

1. 互斥使用
   资源的固有特性
2. 不可抢占
   资源只能自愿放弃，无法抢占
3. 请求和保持
   首先占有资源，不释放，再去申请资源
4. 循环等待

#### 死锁的处理方法概述

##### 1，死锁预防：

方式一：一次性申请所有需要的资源。这样就不会占有资源再去申请其他资源了。破坏了必要条件3。
但是这种方式存在很大的不足：
第一点：在程序运行前就要知道这个程序会申请多少资源，需要预知未来，变成困难
第二点：可能许多资源分配后很长时间后才使用，资源利用率低

方式二：资源按顺序申请，这种方式不会造成环路等待。假设有十个资源，申请的时候必须按照顺序申请，需要资源1就申请资源1，需要资源2就申请资源2，但是如果需要使用资源10，就必须将前面的资源都申请了；但是也会造成很大的资源浪费。

从这里也能看到，死锁预防的方法并不好。

##### 2，死锁避免：

如果系统中的所有进程存在一个可完成的执行序列P1…Pn，（既是不是可以不死锁）则称系统处于安全状态。
那这个安全序列怎么找到呢？使用银行家算法

|      | Allocation | Need  | Available |
| ---- | ---------- | ----- | --------- |
|      | ABC        | ABC   | ABC       |
| P0   | 0 1 0      | 7 4 3 | 2 3 0     |
| P1   | 3 0 2      | 0 2 0 |           |
| P2   | 3 0 2      | 6 0 0 |           |
| P3   | 2 1 1      | 0 1 0 |           |
| P4   | 0 0 2      | 4 3 1 |           |
|      |            |       |           |

![image-20211120234519572](C:\Users\psj\AppData\Roaming\Typora\typora-user-images\image-20211120234519572.png)

AD都可以

银行家算法大意是：如果P1要执行，那么假设让P1执行一下，如果P1执行之后没有死锁，没问题；那就让P1执行。如果P1执行之后引起死锁了，那就不让P1执行。这就是死锁避免。

```c
m 表示资源数量，n表示进程个数
// 其实就是最捞的DFS
int Available[1...m] ;//每种资源剩余数量
int Allocation [ 1...n, 1...m] ;//己分配资源数量
int Need [ 1..n, 1..ml;//进程还需的各种资源数量
int Work [ 1..m] ;//工作向量
bool Finish  [ 1..n] ;//进程是否结束

Work=Available;Finish[1..n]=false;
while(true){
    for (i=1;i<=n; i++)
	{
		if(Finish[i]==false && Need [i] <= Work[i] )
		{
			Work=Work+Allocation[i];
			Finish[i]=true;  break; 
		}
		else
		{
			goto end;
		}
    )
)
End:
	for (i=1;i<=n; i++)
	  	if(Finish[i]==false)return "deadlock";

```



##### 3，死锁检查+恢复：

因为银行家算法的效率太低了，所以采取检测+恢复的方式。定时检测或者资源利用率低的时候检测。但是检测到某些进程死锁之后如何处理呢？回滚？回滚需要机制的支持；而且如果是一些文件修改的进程呢？所以也不好处理。

##### 4，死锁忽略：

因为银行家算法的效率太低了，所以采取检测+恢复的方式。定时检测或者资源利用率低的时候检测。但是检测到某些进程死锁之后如何处理呢？回滚？回滚需要机制的支持；而且如果是一些文件修改的进程呢？所以也不好处理。

---

# 管程

​		管程的目的：。
​		管程的定义：一个锁(临界区)加上0个或若干个条件变量(等待/通知信号量用于管理并发访问的共享数据)。
​		管程实现的一般方法：收集在对象/模块中的相关共享数据；定义方法来访问共享数据。

​		一开始，所有进程在右上角的排队队列中，排队完后进行wait()操作，等到signal()操作唤醒后，执行这个进程的代码。


# 互斥锁 信号量 管程区别

+ **互斥锁同一时间只让一个线程操作进入临界区，侧重于线程互斥**
+ **信号量在某个线程完成工作到某个程度时让某个线程（可以是特定的一个线程）进行工作，侧重于多线程进行时线程之间的同步**
+ **管程分离互斥和对条件同步的关注，让多个条件绑定在一个模块上，算是信号量机制上的一个改进**

​		

# 进程通信

![img](https://images2015.cnblogs.com/blog/836125/201608/836125-20160810003503059-2108512830.png)

### **进程间通信从通信路径上可分为直接通信和间接通信。**

直接通信：进程A直接将信息发给B（不经过内核倒一次）；

间接通信：进程A先把信息发给内核，内核再将信息发给B。

### **直接通信**

为了能够实现有效正确的通信，首先需要知道进程将信息送到哪里去，或者进程从哪里接收数据，就需要 send(B,message) receive(A,message)

其次是链路的建立（发送接收数据之前，通常是双向的）。

链路的建立需要操作系统的支持，因为进程间通信实际上是打破了进程之间的隔离，没有操作系统的支持是无法完成的。

### **间接通信**

对间接通信而言，发送进程需要将信息send到某个区域，这个区域是操作系统指定的在内核中的一个区域，接收方也是从这个区域recieve信息，都不关注这个信息是谁发的或者谁要接收，他们只需要知道把这个信息放到哪里或者在哪里取就可以了。

在这块内核区域内，维护着用于进程间通信的队列：每个消息队列都有一个唯一的ID，两个进程只有共享了一个消息队列才能通信。

操作：创建新的消息队列-》通过消息队列收发消息-》销毁消息队列

原语为send(Q,message) receive(Q,message) Q为用于通信的消息队列。

### **进程间通信从消息传递上可分为阻塞式和非阻塞式**

**阻塞式被认为是同步的**：发送方直到信息被接收之前都处于阻塞状态，接收方直到信息被完全接收之前也是处于阻塞态的。即发送方只有确认信息被接收之后，才能返回进行下一步动作，如继续发送信息。

**非阻塞式被认为是异步的**：发送方发送之后就不管了，接收方同理。

**进程间通信的链路之间可能存在缓冲区**，缓冲区可以是以下三种方式之一：

1）0容量：发送方必须等待接收方接收完成；

2）有限容量：如果队列已满，发送方必须等待；

3）无限容量：发送方不需要等待可以一直发送。

## **进程间通信方式——信号（signal）**

#### 信号的机制

A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。
与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。
Linux内核的进程控制块PCB中包含了信号相关信息，主要指的是阻塞信号集和未决信号集。

阻塞信号集（信号屏蔽字）：将某些信号加入集合，对他们设置屏蔽，当屏蔽某信号后收到该信号，将会被阻塞，直到解除屏蔽后被唤醒
未决信号集：
1.信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。
2.信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。

#### 信号的产生

按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\
系统调用产生，如：kill、raise、abort
软件条件产生，如：定时器alarm
硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)
命令产生，如：kill命令

#### 信号的种类

我们可以通过命令kill -l查看系统所支持的信号种类。
以下列出几个常用信号：

​	SIGINT终止进程，通常我们的Ctrl+C就发送的这个消息。
​	SIGQUIT和SIGINT类似, 但由QUIT字符(通常是Ctrl- / )来控制. 进程收到该消息退出时会产生core文件。
​	SIGKILL消息编号为9，我们经常用kill -9来杀死进程发送的就是这个消息，程序收到这个消息立即终止，这个消息不能被捕获，封锁或这忽略，所以是杀死进程的终极武器。
​	SIGTERM是不带参数时kill默认发送的信号，默认是杀死进程。
​	SIGSTOP停止进程的执行，同SIGKILL一样不可以被应用程序所处理，注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行。
​	SIGCONT当SIGSTOP发送到一个进程时，通常的行为是暂停该进程的当前状态。如果发送SIGCONT信号，该进程将仅恢复执行。除了其他目的，SIGSTOP和SIGCONT用于Unix shell中的作业控制，无法捕获或忽略SIGCONT信号。
​	SIGCHLD子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。

#### 信号的状态

递达：递送并且到达进程。
未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。

#### 信号的处理方式

1. 执行默认动作；
2. 忽略(丢弃).即对信号不做任何处理；
3. 捕捉.定义信号处理函数，当信号发生时，执行相应的处理函数。

## 进程间通信方式——管道

​		**概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。**

​		管道是最早出现的进程间通信的手段。在 shell 中执行命令时，经常将上一个命令的输出作为下一个命令的输入，由多个命令配合完成一件事情。而这就是通过管道来实现的。

​		管道的作用是在有亲缘关系的进程之间传递消息。所谓亲缘关系，是指有一个共同的祖先。所以管道并非只能用于父子进程之间，也可以用在兄弟进程之间，还可以用在祖孙进程之间甚至叔侄进程之间。总而言之，只要共同的祖先曾经调用了 pipe 函数，打开的管道文件就会在 fork 之后，被各个后代进程所共享。打开管道文件就像是创建了一个家族私密场所，由远祖进程来创建，家族所有成员都知晓。家族成员可以将消息存放进该秘密场所，等待另外一头的家族成员来取走消息，阅后即焚。

​		管道是一种文件，可以调用 read、write 和 close 等操作文件的接口来操作管道。另一方面管道又不是一种普通文件，它属于一种独特的文件系统：pipefs。**管道的本质是内核维护了一块缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区内存的操作。**

---

​		管道内存区域的大小必须在页面大小（PAGE）和上限值之间。对于特权用户，还可以修改上限值。

​		管道的容量可以扩大，也可以缩小。缩小管道容量时有一种比较有意思的场景：当前管道中存在的内容大于 fcntl 函数中制定的 size，此时 fcntl 函数会调用失败，并设置错误码为 EBUSY。

​		管道容量有大小，所以在使用管道的过程中要意识到：管道有大小，写入需谨慎，不能连续的写入大量的内容，一旦管道满了，写入操作就会被阻塞；对于读取端，要及时地读取，防止管道被写满，造成写入阻塞。

#### 命名管道（FIFO）

​		**概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。**

​		上述管道虽然实现了进程间通信，但是它具有一定的局限性：首先，这个管道只能是具有血缘关系的进程之间通信；第二，它只能实现一个进程写另一个进程读，而如果需要两者同时进行时，就得重新打开一个管道。

​		为了使任意两个进程之间能够通信，就提出了命名管道（named pipe 或 FIFO）。
1、与管道的区别：提供了一个路径名与之关联，以FIFO文件的形式存储于文件系统中，能够实现任何两个进程之间通信。而匿名管道对于文件系统是不可见的，它仅限于在父子进程之间的通信。
2、FIFO是一个设备文件，在文件系统中以文件名的形式存在，因此即使进程与创建FIFO的进程不存在血缘关系也依然可以通信，前提是可以访问该路径。
3、FIFO(first input first output)总是遵循先进先出的原则，即第一个进来的数据会第一个被读走。

---

​		**命名管道与匿名管道使用的区别：**
​		命名管道创建完成后就可以使用，其使用方法与管道一样，区别在于：命名管道使用之前需要使用open()打开。这是因为：命名管道是设备文件，它是存储在硬盘上的，而管道是存在内存中的特殊文件。==但是需要注意的是，命名管道调用open()打开有可能会阻塞，但是如果以读写方式（O_RDWR）打开则一定不会阻塞；以只读（O_RDONLY）方式打开时，调用open()的函数会被阻塞直到有数据可读；如果以只写方式（O_WRONLY）打开时同样也会被阻塞，直到有以读方式打开该管道。

## 共享内存系统

​		**将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。生命周期随内核。   **

​         共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。

​		采用共享内存的进程间通信，需要通信进程建立共享内存区域。通常，**共享内存区域驻留在创建共享内存段的进程地址空间内。其他希望使用这个共享内存段进行通信的进程应将其附加到自己的地址空间。**需要同步互斥机制的保证。

​		是一种直接通信的方式，直接读取内存就可以看到，不需要一些send，receive等系统调用。

## 进程间通信方式——消息队列

​		管道里的数据作为字节流存在，如果需要数据按照某种结构来实现，需要消息队列，有buffer的size限制。

## 进程间通信SOCKET

​		实现在内核态里。
