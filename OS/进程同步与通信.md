# 进程同步与信号量

**临界区保护信号量    信号量实现进程同步**

### Peterson算法：

```java
进程P0
flag[0] = true;
trun = 1;
while (flag[1] && trun == 1);
临界区
flag[0] = false;

进程P1
flag[1] = true;
trun = 0;
while(flag[0] && turn == 0);
临界区
flag[1] = false;
剩余区
```

​		如果两个进程同时进入，那么flag[0]=flag[1]=true;对于进程P0,当flag[1]=true时，如果不空转，那么turn一定
为0，如果trun为0，进程P1就不可能进入。满足互斥

​		如果P1不在临界区，那么flag[1]=false,trun=0;而这两点无论满足哪一点P0都能进入。满足有空让进。
​		如果P0要求进入，那么flag[0]=true;那么P1不可能一直进入，因为当flag[0]=true时，如果P1想进入，turn必须要为1，但是如果P0不执行，P1每次执行都会将turn设置为0，因此当进程P0要求进入时，P1顶多还能先进入一次（当P0执行到trun=1时切出去执行P1）。满足有限等待。

以上都是考虑两个进程之间的调度，如果有n个进程呢？

## 多个进程调度

### 面包店算法：

面包店:每个进入商店的客户都获得一个号码，号码最小的先得到服务;号码相同时，名字靠前的先服务。

对应到进程切换来说就是给每个进程一个数字，调度的时候选择数字最小的先执行，执行完之后将该号码值为0，如果该进程还需要再次执行，那么就重新获取一个号码，并且这个号码比其他进程的号码都大。

```java
Pi进程
choosing[i]=true; 
num[i]=max(num[0],…，num[n-1 ])+1;	// 进程进来之前先取号，每次进入的时候都取最大那个
choosing[i]=false; 
for(j=0; j<n;j++)
{
	while(choosing[j]);	// 如果该进程在选号码，就停止
	while((num[j]!=0) && (num[j]，j)<(num[i]，i]));	
}
    临界区
num[i]=0;
    剩余区

```

​		首先 i 表示当前进程为Pi，num[j]!=0说明进程j想执行，(num[j],j) < (num[i],i),并且进程Pj的号码比进程Pi的号码小，那么就让进程Pi空转，让进程Pj执行，当进程Pj执行完之后,如果Pj进程不用执行了，那么num[j]==0,如果Pj进程还要执行，那么num[j]肯定大于num[i]，都会使Pi跳出空转。

​		面包店算法含有轮转+标记的意味，轮转体现在：每个进程第二次执行都至多要等n个进程，因为取号的时候是取的最大号，标记就是号码咯。很明显面包店算法也符合“互斥进入”、“有空让进”和“有限等待”。

​		面包店算法有自己的优点也有其缺点，优点前面已经说了，对于多进程的调度实现的比较好，而且是纯软件的不需要硬件支持；缺点就是太麻烦了，代码复杂。
下面说一种简单的方法

### 通过开关中断来实现

```
cin();
临界区
sti();
剩余区

```

cin()表示关中断，sti()开中断。进程怎么切换？还不是通过中断嘛，我直接把中断关了就不用切换了吧。CPU中断的原理：CPU旁边有个INTR寄存器，如果有中断来，就将INTR的某一位置为一，CPU每执行完一条指令之后就看一下是不是有中断来，如果有就执行；cin()函数的作用就是让CPU不看INTR寄存器，这样不管有没有中断来，CPU都不管。

但是这种方式对于多核不好使，因为你只能控制一个CPU，其他的CPU控制不了，而现在的计算机基本上都是多核了。这种方式只适用于单核的小系统。

### 硬件原子指令法

```c
boolean TestAndSet(boolean &x)
{
	boolean rv = x;
	x = true;
	return rv;
}

```

简单的讲，就是TestAndSet在执行的时候不会被打断。还记得最初的“直观想法”吗？就是简单的加锁开锁罢了，上面的这些什么算法都是实现这个加锁开锁的过程。同样硬件原子指令法也是这样，

```c
while(TestAndSet(&lock));
临界区
lock=false;
剩余区

```

很明显对于调度几个方面的要求都是符合的。它为什么叫硬件原子指令法呢？因为TestAndSet这条指令在执行的时候是对硬件有要求的，硬件必须这么设计才能支持这条指令。

# 死锁处理

#### 死锁的四个必要条件：

1. 互斥使用
   资源的固有特性
2. 不可抢占
   资源只能自愿放弃，无法抢占
3. 请求和保持
   首先占有资源，不释放，再去申请资源
4. 循环等待

#### 死锁的处理方法概述

##### 1，死锁预防：

方式一：一次性申请所有需要的资源。这样就不会占有资源再去申请其他资源了。破坏了必要条件3。
但是这种方式存在很大的不足：
第一点：在程序运行前就要知道这个程序会申请多少资源，需要预知未来，变成困难
第二点：可能许多资源分配后很长时间后才使用，资源利用率低

方式二：资源按顺序申请，这种方式不会造成环路等待。假设有十个资源，申请的时候必须按照顺序申请，需要资源1就申请资源1，需要资源2就申请资源2，但是如果需要使用资源10，就必须将前面的资源都申请了；但是也会造成很大的资源浪费。

从这里也能看到，死锁预防的方法并不好。

##### 2，死锁避免：

如果系统中的所有进程存在一个可完成的执行序列P1…Pn，（既是不是可以不死锁）则称系统处于安全状态。
那这个安全序列怎么找到呢？使用银行家算法

|      | Allocation | Need  | Available |
| ---- | ---------- | ----- | --------- |
|      | ABC        | ABC   | ABC       |
| P0   | 0 1 0      | 7 4 3 | 2 3 0     |
| P1   | 3 0 2      | 0 2 0 |           |
| P2   | 3 0 2      | 6 0 0 |           |
| P3   | 2 1 1      | 0 1 0 |           |
| P4   | 0 0 2      | 4 3 1 |           |
|      |            |       |           |

![image-20211120234519572](C:\Users\psj\AppData\Roaming\Typora\typora-user-images\image-20211120234519572.png)

AD都可以

银行家算法大意是：如果P1要执行，那么假设让P1执行一下，如果P1执行之后没有死锁，没问题；那就让P1执行。如果P1执行之后引起死锁了，那就不让P1执行。这就是死锁避免。

```c
m 表示资源数量，n表示进程个数
// 其实就是最捞的DFS
int Available[1...m] ;//每种资源剩余数量
int Allocation [ 1...n, 1...m] ;//己分配资源数量
int Need [ 1..n, 1..ml;//进程还需的各种资源数量
int Work [ 1..m] ;//工作向量
bool Finish  [ 1..n] ;//进程是否结束

Work=Available;Finish[1..n]=false;
while(true){
    for (i=1;i<=n; i++)
	{
		if(Finish[i]==false && Need [i] <= Work[i] )
		{
			Work=Work+Allocation[i];
			Finish[i]=true;  break; 
		}
		else
		{
			goto end;
		}
    )
)
End:
	for (i=1;i<=n; i++)
	  	if(Finish[i]==false)return "deadlock";

```



##### 3，死锁检查+恢复：

因为银行家算法的效率太低了，所以采取检测+恢复的方式。定时检测或者资源利用率低的时候检测。但是检测到某些进程死锁之后如何处理呢？回滚？回滚需要机制的支持；而且如果是一些文件修改的进程呢？所以也不好处理。

##### 4，死锁忽略：

因为银行家算法的效率太低了，所以采取检测+恢复的方式。定时检测或者资源利用率低的时候检测。但是检测到某些进程死锁之后如何处理呢？回滚？回滚需要机制的支持；而且如果是一些文件修改的进程呢？所以也不好处理。
