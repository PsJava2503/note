# 内存的管理与使用

### 内存如何使用：

​		内存使用就是放在内存中的程序能够按照正确的逻辑顺序执行		

---

### 内存的分段机制

虚拟地址=段号+段内地址

程序员眼中的程序：

![在这里插入图片描述](https://img-blog.csdn.net/20181020191956897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbGxpYW1nYXZpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

程序是分为很多段的，每一段都有不同的特点。适用于不同的领域。每一段都是从该段的地址0开始的。就是说主程序存放的地方地址应该是从零开始的，变量存放的地方地址也应该是从零开始的，其他区域也是如此。用户程序里面每个区域都有其自己的特点，比如主程序这部分应该是只读的，变量所在的区域是可写的，函数库应该是可以可以链接也可以不链接的，栈应该只能单向增加。如果是将整个程序都放在一块的话这些要求肯定不能保证。因此程序应该是要分段保存的，并且这些段都有自己的特点。

既然是分段的，那么是怎么定义地址的呢？还是基址+偏移。只不过这里的基址不再是这个程序的起始位置了，而是这一段程序的起始地址。这个基址放在段表里面
![在这里插入图片描述](https://img-blog.csdn.net/20181020192222247?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbGxpYW1nYXZpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​		CPU每执行一条牵涉到地址的指令都会查一下PCB里面这个进程段表，从而确定物理地址。这个表其实就是LDT表，有一个专门存放该表地址的寄存器LDTR寄存器。到目前为止内存已经可以使用起来了。因为地址已经设定好了。

​		**GDT表就是操作系统进程对应的段表，LDT表就是操作系统管理的进程的段表，在PCB中**

---

​		在未开启分页机制时，`段基址 + 段内偏移`计算出的**线性地址**就是**物理地址**，对于一个程序，由于线性地址是由编译器编译出来的，它本身是连续的，所以物理地址也必须要连续。

**造成问题：**

当内存中有三个进程A、B、C如下图，当B执行结束后，执行进程D，D的大小位20M+3kb，由于需要连续的内存执行D，而D需要的内存空间，大于内存中任何一块空闲的区域，导致内存不足。

![img](https://upload-images.jianshu.io/upload_images/6058448-9975389ecd695064.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

解决方法：

将**线性地址**到**物理地址**一一对应的关系解除，重新建立一种映射，使得线性地址是连续的，而物理地址可以不连续。

在CPU中，这种映射关系通过一张表来实现，该表就是页表。

---

### 如何在内存里面找到空闲分区

​		首先考虑的问题应该是如何分割内存，前面说的将内存分段以用户的角度看的，现在来单纯的考虑内存该如何分区。

#### 固定分区

​		第一种方式固定分区，即操作系统初始化的时候将内存等分为n个分区，大小一样。但是程序运行的时候内存的需求有大有小，如果采用这种方式势必会造成很大的浪费。

#### 可变分区

​		第二种方式可变分区，可变分区的基本思想是建立已分配分区表和空闲分区表，已分配分区表中记录了已经使用了的内存有哪些，注明了这一段内存是哪个程序使用了，起始地址和长度是多少。空闲分区表记录了内存中的空闲区域，包括起始地址和长度。这时候如果有段内存请求，根据请求的内存大小以及空闲分区表上面空闲分区的大小来给这个请求分配内存，同时更新这两张表；如果有进程运行完了也同样更新这两张表。这样做的好处是：可以给需要大内存的程序分配大块内存，给需要小内存的程序分配小内存，提高内存利用率。

#### 可变分区的三种适配方式

​		可变分区的方式还有一个需要考虑的问题，比如有一个请求需要40K内存，空闲分区表里面有很多个大于40K的内存区域，应该选择哪一个分配呢？

首先适配，顾名思义，就是将第一个符合该请求的内存分配出去。这样的好处是：快。时间复杂度是O(1)

最佳适配，把所有的空闲内存块都看一遍，将最接近40K并且大于40K的内存分配给它。这样的好处是可以可以提高内存的使用率。

最差适配，把所有的空闲内存块都看一遍，将最大块的内存分配给它，并且该内存块一定大于40K。这样的好处是剩下的内存块都比较均匀。

​		三种适配方式各有其优劣；选择哪种适配方式要根据实际情况来。

#### 可变分区造成的问题

​		比如有一个160K的内存请求，但是空闲分区表里面只有一个150K的和一个50K的，都不够，怎么办。这其实就是内存碎片。一种方式是内存紧缩，即将150K的内存大小和50K的想办法移到一起。但是这种方式比较耗费时间，并且这段时间电脑是不能工作的。那有没有方法可以消除掉内存碎片呢？答案是将内存分页

​		将页作为内存分配的最小单元，假设一页为4K，如果一个内存请求是13K，那么就给它分配4页。这样一个进程最多也只会浪费不到4K的内存区域，这种浪费是很小的，因此也不需要进行内存紧缩了。那这种方式会产生内存碎片吗？其实也有会一些内存没有使用到，但是注意这种思想，页是一个单位，每次分配的内存都是整数个页，也就是将这些分配出去的页都看成是已经使用的了，所以就没有内存碎片。因此从内存角度来说这种方式是比较好的，也就是物理内存想要分页，但是用户程序希望是分段。那这个段和页是如何结合的呢？后面会讲。


### 内存的分页机制：

​		一页4k为单位进行分配**操作系统开机初始化过程中的mem_map就是以4k为单位记录**

虚拟页和物理页的长度固定且相等。

页表表示为为：**虚拟页号到物理页号的映射表（单级页表下）**

​		虚拟地址=虚拟页号+页内偏移量；例如逻辑地址（0x02||0x240）对应的物理页号为3，得到物理地址0x3240，这里是由MMU进行计算的。（4k=1000h）

只存在内部碎片，但最多浪费一页，即4k。

---

### 多级页表和快表（Translation Lookaside Buffer,TLB）

​		假设页面尺寸为4K，地址是32位，那么就有220个页面，页表里面就有220个页表项，如果每个页表项是4个字节，2^20个就是4M；系统并发十个进程，需要40M内存。如果并发一百个就是400M内存，这无疑是一个很大的开销。

​		但是实际上大部分的逻辑地址根本不会用到。为什么？如果你跑一个小程序，可能只需要几M或者几十M，也就是说页表里面用到的项只占2^20的很小一部分，那么能不能把不需要的那些项给屏蔽掉呢，也就是不存储那些项。
​		为了压缩页表，OS引进了多级结构的页表，用于满足虚拟内存的要求。 

#### 第一种尝试：页表里面只存放用到的页

​		比如一个程序用到了第1，3，5，6页，那么页表里面只需要存储这四页对应的页框号，但是这样的话页表里面的项就不连续了，这样找某一页对应的页框就不能直接使用偏移量的形式了。比较好的方法是折半查找（因为页号是有顺序的）。但是即便使用折半查找耗费的时间也会比使用偏移量大很多倍。比如如果一个表项有210个，时间复杂度log(210)=10,也就是需要10次，而如果使用偏移量就只需要一次就好了。所以页表里面的页号必须是连续的。

#### 第二种尝试：多级页表，页目录表+页表

​		一个逻辑地址用10bits的页目录号+10bits的页号+12bits的偏移组成。页目录表的每一项对应一个页表，然后再根据页表找到对应的页。这种思想就类似与书本，目录的地方有一个章目录（页目录表）和节目录（页表），如果要查找某一节的内容首先找到这一章的地方，然后再查具体的某一节。我如果要找第五章的第4节，那么前面四章都不用看，直接找第五章就行了，这样除了第五章之外的页号对应的页框号的就不用存了。能节省大量内存；并且保证了章目录和节目录都是连续的，这就意味着可以使用偏移量的形式查找对应的章节。如下图：

![在这里插入图片描述](https://img-blog.csdn.net/20181021115815384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbGxpYW1nYXZpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**多级页表的设计减少了页表所用的空间大小，因为多级页表允许页表结构出现空洞，而单极页表不允许 **

#### 快表

​		多级页表这种方式也存在一个问题，每一次访问的时候都要根据章目录找到页目录再找到具体的页。也就是需要访问三次内存；cpu每一条指令执行的时间其实大部分都是浪费在访问内存上，cpu的执行速度是非常快的，比起访问内存的时间几乎可以忽略了；换言之，两级页表的形式虽然提高了空间效率，但是在时间上其实是变成了原来的3倍的；这还只是两级页表，如果是4级或者5级的，因为电脑不是32位的啊，现在基本上都是64位的了。为了减少MMU地址翻译访问内存的次数，引入了**快表TLB**。TLB缓存了虚拟页号到物理页号的映射关系（是cpu内部的硬件部件，x86是由硬件（MMU）管理的）；

​		**为什么TLB命中率高？**时间局部性和空间局部性：TLB中缓存的是一个内存页，所以命中率高。

##### TLB刷新

​	由于TLB使用虚拟地址进行查询，所以页表切换（进程切换）也要主动刷新TLB，或者给缓存项打上标签（x86中的PCID,Process Context Identifier），再将这个写入页表基地址寄存器的空闲位。

