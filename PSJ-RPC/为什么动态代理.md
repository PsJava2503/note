# 为什么动态代理

​		由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。

　　如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行helloWorldService.sayHello("test")时，实质上调用的是远端的服务。这种方式其实就是RPC（Remote Procedure Call Protocol），在各大互联网公司中被广泛使用，如阿里巴巴的hsf、dubbo（开源）、Facebook的thrift（开源）、Google grpc（开源）、Twitter的finagle（开源）等。

　　要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：

![img](https://images2015.cnblogs.com/blog/522490/201510/522490-20151003120412386-363334260.png)

1）服务消费方（client）调用以本地调用方式调用服务；

2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

3）client stub找到服务地址，并将消息发送到服务端；

4）server stub收到消息后进行解码；

5）server stub根据解码结果调用本地的服务；

6）本地服务执行并将结果返回给server stub；

7）server stub将返回结果打包成消息并发送至消费方；

8）client stub接收到消息，并进行解码；

9）服务消费方得到最终结果。

​		RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

### 不用动态代理会是怎么样

上述图示看似和一个 http 请求没有区别，别急，我们举一个具体的例子：

​		有一个客户类 User 代表用户的信息，这些信息存储在服务器 B 上面，服务器B提供查询用户的方法。

​		假设现在客户端A同样需要一个查询用户的方法 findUserById()，需要这个方法去访问服务器 B，一般的步骤是：

+ A把参数、接口和方法等信息序列化
+ A把序列化的信息通过网络发送给 B
+ B 收到信息之后，反序列化解析信息
+ B 根据解析到的信息找到方法，执行得到结果
+ B 把结构序列化通过网络发送给 A
+ A 反序列化解析信息，得到结果

​		为了完成上述的功能，最直接的做法是在 findUserById() 方法里面写这些序列化、网络请求、反序列化的代码:

+ 代码复杂，网络请求序列化等方法和业务代码混杂在一起
+ 如果用户类 User 改变，那么代码的序列化等部分都要变
+ 如果有很多地方需求这种远程调用，需要为每一个方法写这一大堆代码
+ 如果远程服务器地址、端口甚至服务改变，需要修改每一个远程调用的方法

​		一个好的解决方法是用动态代理，这样就和方法无关，一系列的方法只需要写一个代理类，修改代码也只需要修改代理类。这其实就是 RPC 的原理：利用动态代理，创建代理类去实现这些细节，把接口（方法）作为参数传递，而不是绑定方法.

