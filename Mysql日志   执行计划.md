# Mysql日志  || 执行计划

`MySQL` 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。

后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 `IO` 开销，提升性能。

更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。

然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。

![img](https://camo.githubusercontent.com/2d16351f0a69d8b8f6fdd64f4df08d45349992e9750eb8bd37f3ca5eaa7b3421/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30332e706e67)

理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。

### 刷盘时机

`InnoDB` 存储引擎为 `redo log` 的刷盘策略提供了 `innodb_flush_log_at_trx_commit` 参数，它支持三种策略：

- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作
- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）
- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache

`innodb_flush_log_at_trx_commit` 参数默认为 1 ，也就是说当事务提交时对 redo log 进行刷盘

另外，`InnoDB` 存储引擎有一个后台线程，每隔`1` 秒，就会把 `redo log buffer` 中的内容写到文件系统缓存（`page cache`），然后调用 `fsync` 刷盘。

![img](https://camo.githubusercontent.com/c5f4ad834097e71a5fc35f885448456cba9a17849b6c4839d67b62b8ac36bc6b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30342e706e67)

也就是说，一个没有提交事务的 `redo log` 记录，也可能会刷盘。

因为在事务执行过程 `redo log` 记录是会写入`redo log buffer` 中，这些 `redo log` 记录会被后台线程刷盘。

除了后台线程每秒`1`次的轮询操作，还有一种情况，当 `redo log buffer` 占用的空间即将达到 `innodb_log_buffer_size` 一半的时候，后台线程会主动刷盘。

![img](https://camo.githubusercontent.com/a39be760278c5d4dfb90fd69f78d2affb9f8bf4c742c73140b61e617a4b29664/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30362e706e67)

![img](https://camo.githubusercontent.com/b090579b6f3fec0cfa40cca1a8a2bf992a892343c13816d91432d5aaa63b1a7a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30372e706e67)

为`1`时， 只要事务提交成功，`redo log`记录就一定在硬盘里，不会有任何数据丢失。

如果事务执行期间`MySQL`挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。

![img](https://camo.githubusercontent.com/9e44df25f593ca86ef04e7cc6781e8db5e12b8b46e1c368df41e075494f4a2e2/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30392e706e67)

为`2`时， 只要事务提交成功，`redo log buffer`中的内容只写入文件系统缓存（`page cache`）。

如果仅仅只是`MySQL`挂了不会有任何数据丢失，但是宕机可能会有`1`秒数据的丢失。



### redo log 小结

相信大家都知道 `redo log` 的作用和它的刷盘时机、存储形式。

现在我们来思考一个问题： **只要每次把修改后的数据页直接刷盘不就好了，还有 `redo log` 什么事？**

它们不都是刷盘么？差别在哪里？

```
1 Byte = 8bit
1 KB = 1024 Byte
1 MB = 1024 KB
1 GB = 1024 MB
1 TB = 1024 GB
```

实际上，数据页大小是`16KB`，刷盘比较耗时，可能就修改了数据页里的几 `Byte` 数据，有必要把完整的数据页刷盘吗？

而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

如果是写 `redo log`，一行记录可能就占几十 `Byte`，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。

所以用 `redo log` 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。



## binlog

`redo log` 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 `InnoDB` 存储引擎。

而 `binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于`MySQL Server` 层。

不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志。

`binlog`会记录所有涉及更新数据的逻辑操作，并且是顺序写。

### 写入机制

`binlog`的写入时机也非常简单，事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。

因为一个事务的`binlog`不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为`binlog cache`。

我们可以通过`binlog_cache_size`参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（`Swap`）。

`binlog`日志刷盘流程如下

![img](https://camo.githubusercontent.com/4ac4a163c07cdcbeaaae3440f714a302824a21192941184a5cde3c9c9b06a617/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30342f30342e706e67)

刷磁盘的时机分为三种：

为`0`的时候，表示每次提交事务都只`写到page chche`，由系统自行判断什么时候刷到磁盘`。

​	虽然性能得到提升，但是机器宕机，`page cache`里面的 binglog 会丢失。



为了安全起见，可以设置为`1`，表示每次提交事务都会执行`直接刷盘`



最后还有一种折中方式，可以设置为`N(N>1)`，表示每次提交事务都`写pagecache`，但累积`N`个事务后才`刷盘`。

​	在出现`IO`瓶颈的场景里，将`sync_binlog`设置成一个比较大的值，可以提升性能。

​	同样的，如果机器宕机，会丢失最近`N`个事务的`binlog`日志。



## 两阶段提交

`redo log`（重做日志）让`InnoDB`存储引擎拥有了崩溃恢复能力。

`binlog`（归档日志）保证了`MySQL`集群架构的数据一致性。

虽然它们都属于持久化的保证，但是则重点不同。

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。





`redo log`与`binlog`两份日志之间的逻辑不一致，会出现什么问题？

​		数据不一致

以`update`语句为例，假设`id=2`的记录，字段`c`值是`0`，把字段`c`值更新成`1`，`SQL`语句为`update T set c=1 where id=2`。

​		写完`redo log`日志后，`binlog`日志写期间发生了异常：由于`binlog`没写完就异常，这时候`binlog`里面没有对应的修改记录。因此，之后用`binlog`日志恢复数据时，就会少这一次更新，恢复出来的这一行`c`值是`0`，而原库因为`redo log`日志恢复，这一行`c`值是`1`，最终数据不一致。

​		

为了解决两份日志之间的逻辑一致问题，`InnoDB`存储引擎使用**两阶段提交**方案。

原理很简单，将`redo log`的写入拆成了两个步骤`prepare`和`commit`，这就是**两阶段提交**。

![img](https://camo.githubusercontent.com/12475e1d28c977069f6abe5e4979de20a4226fc29e23ad791346a08c81e243a7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30352f30342e706e67)

使用**两阶段提交**后，写入`binlog`时发生异常也不会有影响，因为`MySQL`根据`redo log`日志恢复数据时，发现`redo log`还处于`prepare`阶段，并且没有对应`binlog`日志，就会回滚该事务。

